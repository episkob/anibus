package it.r2u.anibus.service;

import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * Vulnerability Scanner
 * Identifies known CVEs based on service name and version
 */
public class VulnerabilityScanner {
    
    public static class Vulnerability {
        private String cve;
        private String severity; // CRITICAL, HIGH, MEDIUM, LOW
        private String description;
        private String affectedVersions;
        
        public Vulnerability(String cve, String severity, String description, String affectedVersions) {
            this.cve = cve;
            this.severity = severity;
            this.description = description;
            this.affectedVersions = affectedVersions;
        }
        
        public String getCve() { return cve; }
        public String getSeverity() { return severity; }
        public String getDescription() { return description; }
        public String getAffectedVersions() { return affectedVersions; }
        
        @Override
        public String toString() {
            String icon = switch (severity) {
                case "CRITICAL" -> "[CRITICAL]";
                case "HIGH" -> "[HIGH]";
                case "MEDIUM" -> "[MEDIUM]";
                default -> "ðŸŸ¢";
            };
            return String.format("%s %s [%s] - %s", icon, cve, severity, description);
        }
    }
    
    // Known vulnerability patterns
    private static final Map<String, List<VulnerabilityPattern>> VULNERABILITY_DB = new HashMap<>();
    
    static {
        // Apache HTTP Server vulnerabilities
        addVulnerability("apache", "2\\.4\\.[0-4]\\d", 
            new Vulnerability("CVE-2021-44790", "CRITICAL", "Mod_lua Buffer Overflow", "2.4.0-2.4.51"));
        addVulnerability("apache", "2\\.4\\.[0-3]\\d", 
            new Vulnerability("CVE-2021-41773", "CRITICAL", "Path Traversal and RCE", "2.4.49-2.4.50"));
        addVulnerability("apache", "2\\.2\\..*", 
            new Vulnerability("CVE-2017-15710", "HIGH", "Out of bounds write", "2.2.x (EOL)"));
        
        // Nginx vulnerabilities
        addVulnerability("nginx", "1\\.1[0-6]\\..*", 
            new Vulnerability("CVE-2021-23017", "HIGH", "DNS Resolver Off-by-One", "0.6.18-1.20.0"));
        addVulnerability("nginx", "1\\.[0-9]\\..*", 
            new Vulnerability("CVE-2019-9511", "HIGH", "HTTP/2 DoS", "1.9.5-1.17.2"));
        addVulnerability("nginx", "0\\..*", 
            new Vulnerability("CVE-2013-2028", "MEDIUM", "Buffer Overflow", "0.x.x"));
        
        // OpenSSH vulnerabilities
        addVulnerability("openssh", "[1-7]\\.[0-9].*", 
            new Vulnerability("CVE-2023-38408", "HIGH", "RCE in ssh-agent forwarding", "<9.3p2"));
        addVulnerability("openssh", "[1-8]\\..*", 
            new Vulnerability("CVE-2021-41617", "MEDIUM", "Local privilege escalation", "<8.8"));
        addVulnerability("openssh", "[1-6]\\.[0-9].*", 
            new Vulnerability("CVE-2016-10012", "HIGH", "Shared memory attack", "<7.4"));
        
        // MySQL vulnerabilities
        addVulnerability("mysql", "5\\.[0-7]\\..* ", 
            new Vulnerability("CVE-2023-21980", "HIGH", "Privilege escalation", "5.7.x, 8.0.x"));
        addVulnerability("mysql", "5\\.[0-6]\\..*", 
            new Vulnerability("CVE-2016-6662", "CRITICAL", "Root privilege escalation", "<5.7.15"));
        
        // PostgreSQL vulnerabilities
        addVulnerability("postgresql", "1[0-4]\\..*", 
            new Vulnerability("CVE-2023-39417", "HIGH", "Extension script injection", "<15.4"));
        addVulnerability("postgresql", "[1-9]\\..*", 
            new Vulnerability("CVE-2021-32027", "HIGH", "Buffer overflow", "<13.3"));
        
        // Redis vulnerabilities
        addVulnerability("redis", "[1-6]\\.[0-2]\\..*", 
            new Vulnerability("CVE-2022-24735", "CRITICAL", "Lua sandbox escape + RCE", "<6.2.7"));
        addVulnerability("redis", "[1-5]\\..*", 
            new Vulnerability("CVE-2021-32762", "HIGH", "Integer overflow leading to RCE", "<6.2.5"));
        
        // MongoDB vulnerabilities
        addVulnerability("mongodb", "[1-4]\\..*", 
            new Vulnerability("CVE-2021-20329", "HIGH", "Denial of service", "<4.4.6"));
        addVulnerability("mongodb", "[2-3]\\..*", 
            new Vulnerability("CVE-2019-2386", "MEDIUM", "Incorrect authorization", "3.x-4.0.x"));
        
        // Tomcat vulnerabilities
        addVulnerability("tomcat", "10\\.0\\.[0-9]", 
            new Vulnerability("CVE-2023-41080", "HIGH", "Open redirect", "10.0.0-10.0.12"));
        addVulnerability("tomcat", "9\\.[0]\\..*", 
            new Vulnerability("CVE-2021-41079", "HIGH", "Apache Tomcat RCE", "9.0.0-9.0.52"));
        addVulnerability("tomcat", "[6-8]\\..*", 
            new Vulnerability("CVE-2020-1938", "CRITICAL", "Ghostcat AJP File Read/Inclusion", "<9.0.31"));
        
        // Docker vulnerabilities
        addVulnerability("docker", "1[0-9]\\..*", 
            new Vulnerability("CVE-2021-21285", "MEDIUM", "Unauthorized access to data", "<20.10.3"));
        addVulnerability("docker", "1[0-8]\\..*", 
            new Vulnerability("CVE-2019-14271", "CRITICAL", "Container escape", "<19.03.1"));
        
        // Kubernetes vulnerabilities
        addVulnerability("kubernetes", "1\\.2[0-4]\\..*", 
            new Vulnerability("CVE-2023-3955", "HIGH", "Privilege escalation", "<1.25.12"));
        addVulnerability("kubernetes", "1\\.1[0-9]\\..*", 
            new Vulnerability("CVE-2021-25741", "HIGH", "Symlink Exchange Vulnerability", "<1.22.x"));
        
        // ProFTPD vulnerabilities
        addVulnerability("proftpd", "1\\.3\\.[0-5].*", 
            new Vulnerability("CVE-2019-12815", "CRITICAL", "Arbitrary file copy", "1.3.5-1.3.6"));
        
        // vsftpd vulnerabilities
        addVulnerability("vsftpd", "2\\.3\\.4", 
            new Vulnerability("CVE-2011-2523", "CRITICAL", "Backdoor in version 2.3.4", "2.3.4"));
        
        // Jenkins vulnerabilities
        addVulnerability("jenkins", "2\\..*", 
            new Vulnerability("CVE-2024-23897", "CRITICAL", "Arbitrary file read", "<2.442"));
        addVulnerability("jenkins", "[1-2]\\..*", 
            new Vulnerability("CVE-2023-27898", "HIGH", "RCE via crafted requests", "Multiple versions"));
        
        // Elasticsearch vulnerabilities
        addVulnerability("elasticsearch", "[1-7]\\..*", 
            new Vulnerability("CVE-2021-22145", "HIGH", "Memory exhaustion DoS", "7.10.0-7.13.3"));
        addVulnerability("elasticsearch", "[1-6]\\..*", 
            new Vulnerability("CVE-2015-1427", "CRITICAL", "RCE via Groovy scripting", "<1.4.3"));
        
        // PHP vulnerabilities
        addVulnerability("php", "[5-7]\\.[0-4]\\..*", 
            new Vulnerability("CVE-2019-11043", "CRITICAL", "PHP-FPM RCE", "7.1.x-7.3.x"));
        addVulnerability("php", "5\\.[0-5]\\..*", 
            new Vulnerability("CVE-2012-1823", "CRITICAL", "CGI RCE", "<5.3.12, <5.4.2"));
    }
    
    private static class VulnerabilityPattern {
        String versionPattern;
        Vulnerability vulnerability;
        
        VulnerabilityPattern(String versionPattern, Vulnerability vulnerability) {
            this.versionPattern = versionPattern;
            this.vulnerability = vulnerability;
        }
    }
    
    private static void addVulnerability(String service, String versionPattern, Vulnerability vuln) {
        VULNERABILITY_DB.computeIfAbsent(service.toLowerCase(), k -> new ArrayList<>())
                        .add(new VulnerabilityPattern(versionPattern, vuln));
    }
    
    /**
     * Scan for vulnerabilities based on service and banner
     */
    public static List<Vulnerability> scanVulnerabilities(String serviceName, String banner) {
        List<Vulnerability> found = new ArrayList<>();
        
        if (serviceName == null || serviceName.isEmpty()) {
            return found;
        }
        
        String lowerService = serviceName.toLowerCase();
        String version = extractVersion(banner);
        
        // Check each service in our database
        for (Map.Entry<String, List<VulnerabilityPattern>> entry : VULNERABILITY_DB.entrySet()) {
            String dbService = entry.getKey();
            
            // Check if this service matches
            if (lowerService.contains(dbService) || dbService.contains(lowerService)) {
                // Check version patterns
                for (VulnerabilityPattern pattern : entry.getValue()) {
                    if (version != null && Pattern.matches(pattern.versionPattern, version)) {
                        found.add(pattern.vulnerability);
                    } else if (version == null && banner != null) {
                        // If we can't extract version but banner matches service, show generic warning
                        continue;
                    }
                }
            }
        }
        
        // Additional check: outdated/EOL software
        if (version != null) {
            Vulnerability eolWarning = checkEndOfLife(lowerService, version);
            if (eolWarning != null) {
                found.add(eolWarning);
            }
        }
        
        return found;
    }
    
    /**
     * Extract version from banner
     */
    private static String extractVersion(String banner) {
        if (banner == null || banner.isEmpty()) {
            return null;
        }
        
        // Common version patterns: X.Y.Z, X.Y, vX.Y.Z, etc.
        Pattern pattern = Pattern.compile("\\b(\\d+\\.\\d+(?:\\.\\d+)?(?:\\.\\d+)?)\\b");
        Matcher matcher = pattern.matcher(banner);
        
        if (matcher.find()) {
            return matcher.group(1);
        }
        
        return null;
    }
    
    /**
     * Check if software is End-of-Life
     */
    private static Vulnerability checkEndOfLife(String service, String version) {
        try {
            String[] parts = version.split("\\.");
            if (parts.length < 2) return null;
            
            int major = Integer.parseInt(parts[0]);
            
            // Check EOL versions
            if (service.contains("apache")) {
                if (major < 2 || (major == 2 && Integer.parseInt(parts[1]) < 4)) {
                    return new Vulnerability("EOL", "HIGH", "Apache version is End-of-Life", "< 2.4");
                }
            } else if (service.contains("nginx")) {
                if (major == 0) {
                    return new Vulnerability("EOL", "MEDIUM", "Nginx 0.x is End-of-Life", "0.x");
                }
            } else if (service.contains("php")) {
                if (major < 8 && major != 7) {
                    return new Vulnerability("EOL", "HIGH", "PHP version is End-of-Life", "< 7.4");
                }
            } else if (service.contains("mysql")) {
                if (major < 5) {
                    return new Vulnerability("EOL", "HIGH", "MySQL version is End-of-Life", "< 5.0");
                }
            } else if (service.contains("postgresql")) {
                if (major < 11) {
                    return new Vulnerability("EOL", "MEDIUM", "PostgreSQL version approaching EOL", "< 11");
                }
            }
        } catch (NumberFormatException e) {
            // Ignore parsing errors
        }
        
        return null;
    }
    
    /**
     * Format vulnerability list for display
     */
    public static String formatVulnerabilities(List<Vulnerability> vulnerabilities) {
        if (vulnerabilities == null || vulnerabilities.isEmpty()) {
            return "âœ… No known vulnerabilities";
        }
        
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("[WARN] Found %d potential vulnerabilities:\n", vulnerabilities.size()));
        
        for (Vulnerability vuln : vulnerabilities) {
            sb.append("  ").append(vuln.toString()).append("\n");
        }
        
        return sb.toString().trim();
    }
}
